# 实体抽取业务流程设计（基于当前项目现状，已去除证据）

## 总览
- 目标：在不维护证据（candidate_evidence）的前提下，完成“剧本 → 候选实体 → 规范资产”的工程化流程，确保可用、简洁、可回溯（通过 artifact_snapshot）。
- 适用范围：当前仓库的后端接口与数据库模型，结合外部抽取器（离线任务/脚本）落库候选实体。
- 核心结论：
  - 候选实体以行级数据存储在 `candidate_entity`，不再维护证据表；
  - 规范资产与别名分别由 `canonical_asset`、`canonical_asset_alias` 管理；
  - 原始 LLM 输出等大上下文由 `artifact_snapshot` 存档，用于审计与复现；
  - 运行记录 `extraction_run` 用于串联流程与可视化进度。

## 角色与数据对象
- 抽取器（外部服务/脚本）：读取剧本，运行 LLM 或规则，写入 `candidate_entity` 与 `artifact_snapshot`，创建/更新 `extraction_run`。
- 后端 API：提供项目、剧本、运行、候选实体读写，资产与别名管理。
- 前端：围绕“候选与资产”的人工归并与管理。

主要数据表：
- 项目与剧本：`project`、`script`
- 标准化剧本：`normalized_script`（只读）
- 运行记录：`extraction_run`
- 候选实体：`candidate_entity`
- 规范资产与别名：`canonical_asset`、`canonical_asset_alias`
- 产物快照：`artifact_snapshot`

## 端到端流程
### A. 项目初始化
- 创建项目：`POST /projects/`
- 上传剧本：`POST /projects/{project_uid}/scripts/`
- 查看剧本内容：`GET /scripts/{uid}`
- 查看标准化剧本（若已入库）：`GET /scripts/{uid}/normalized`（当前后端不提供写入，需由外部程序入库）

### B. 启动抽取运行（Step 2）
- 创建运行记录：`POST /runs/`（step=2，带项目与剧本 uid）
- 抽取器读取剧本（或标准化剧本），执行 LLM/规则抽取，生成候选实体集合。
- 抽取器写入候选实体到 `candidate_entity`，字段建议：
  - `uid`：`cand_{uuid}`
  - `run_uid`：绑定本次运行
  - `raw_name`、`entity_type`、`confidence`
  - 初始 `canonical_asset_uid` 为空
- 可选：将完整 LLM 原始输出写入 `artifact_snapshot`（`run_uid` 关联），便于审计复现。

### C. 候选实体查看与人工归并（Step 3）
- 列出本次运行的候选实体：`GET /runs/{run_uid}/candidates`（仅返回实体基本信息）
- 如需创建规范资产：`POST /assets/`（可带初始别名）
- 如需补充别名：`POST /assets/{uid}/aliases`
- 将候选实体归并到资产：`PATCH /candidates/{uid}`（设置 `canonical_asset_uid`）
- 删除错误的候选：`DELETE /candidates/{uid}`
- 可选：创建 Step 3 的运行记录（`POST /runs/`，step=3）用于标记归并阶段进度。

### D. 资产管理（主数据）
- 列表与筛选：`GET /assets/?project_uid=...&type=...&skip=&limit=`
- 详情：`GET /assets/{uid}`
- 更新资产信息：`PATCH /assets/{uid}`
- 管理别名：`POST /assets/{uid}/aliases`、`DELETE /aliases/{uid}`

### E. 审计与复现
- 使用 `artifact_snapshot` 保存抽取器的原始输出、聚类结果等；
- 通过 `run_uid` 串联一次“抽取/归并”的全部动作，便于追踪。

## 接口使用清单（最小闭环）
- 项目与剧本
  - `POST /projects/`
  - `POST /projects/{project_uid}/scripts/`
  - `GET /scripts/{uid}`
  - `GET /scripts/{uid}/normalized`（只读）
- 运行记录
  - `POST /runs/`
  - `GET /runs/{uid}`
  - `GET /scripts/{script_uid}/runs`
- 候选实体
  - `GET /runs/{run_uid}/candidates`
  - `PATCH /candidates/{uid}`
  - `DELETE /candidates/{uid}`
- 资产与别名
  - `POST /assets/`
  - `GET /assets/?project_uid=...`
  - `GET /assets/{uid}`
  - `PATCH /assets/{uid}`
  - `POST /assets/{uid}/aliases`
  - `DELETE /aliases/{uid}`

## 操作示例（cURL 顺序）
1) 创建项目
```bash
curl -s -X POST http://localhost:8000/api/v1/projects/ -H "Content-Type: application/json" -d '{"name":"Proj","description":"Desc"}'
```
2) 上传剧本
```bash
curl -s -X POST http://localhost:8000/api/v1/projects/{project_uid}/scripts/ -H "Content-Type: application/json" -d '{"name":"Ep1","content":"..."}'
```
3) 创建 Step 2 运行记录
```bash
curl -s -X POST http://localhost:8000/api/v1/runs/ -H "Content-Type: application/json" -d '{"project_uid":"{project_uid}","script_uid":"{script_uid}","step":2,"model_config":{"model":"gpt-4","temperature":0}}'
```
4) 查看候选（在抽取器写入候选后）
```bash
curl -s http://localhost:8000/api/v1/runs/{run_uid}/candidates
```
5) 创建资产并归并
```bash
curl -s -X POST http://localhost:8000/api/v1/assets/ -H "Content-Type: application/json" -d '{"project_uid":"{project_uid}","name":"张三","type":"person","description":"...","aliases":["老张"]}'
curl -s -X PATCH http://localhost:8000/api/v1/candidates/{cand_uid} -H "Content-Type: application/json" -d '{"canonical_asset_uid":"{asset_uid}"}'
```

## 抽取器落库规范（示例伪代码）
```python
from sqlmodel import SQLModel, Session, create_engine
from app.models import CandidateEntity, ArtifactSnapshot

engine = create_engine("postgresql+psycopg2://user:pass@host/db")
with Session(engine) as s:
    s.add(CandidateEntity(uid="cand_x", run_uid="run_x", raw_name="老张", entity_type="person", confidence=0.92))
    s.add(ArtifactSnapshot(uid="art_x", run_uid="run_x", content_json={"raw": "..." }))
    s.commit()
```

## 约束与最佳实践
- 必填关联：所有候选实体必须带 `run_uid`，资产必须带 `project_uid`。
- 去除证据后的人机协作：依赖标准化剧本与别名系统完成归并，必要时通过 `artifact_snapshot` 复核。
- 命名规范：统一使用 `asset_{uuid}`、`cand_{uuid}`、`run_{uuid}`、`alias_{uuid}`。
- 软删除：核心表采用 `is_deleted` 标记，避免误删与日志缺失。
- 并发与重跑：同一剧本可创建多次运行记录；前端按运行维度展示候选。

## 环境与验证
- 启动与依赖：参考后端说明 [backend/README.md](file:///Users/apple/dev/full-stack-fastapi-template/backend/README.md)
- 质量检查：`uv run ruff check .`、`uv run mypy app`
- 后端测试：`uv run pytest -q`（当前 63 通过）

## 参考链接（代码）
- 路由入口：[main.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/main.py)
- 项目与剧本路由：[projects.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/routes/projects.py)、[scripts.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/routes/scripts.py)
- 运行与候选路由：[runs.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/routes/runs.py)、[candidates.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/routes/candidates.py)
- 资产与别名路由：[assets.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/routes/assets.py)、[aliases.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/api/routes/aliases.py)
- 数据模型：[models.py](file:///Users/apple/dev/full-stack-fastapi-template/backend/app/models.py)
